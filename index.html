<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Merlin Game</title>
  <style>
    :root {
      --main-bg: linear-gradient(135deg, #f8ffae 0%, #43cea2 100%);
      --card-front: linear-gradient(145deg, #f6d365 0%, #fda085 100%);
      --card-back: linear-gradient(145deg, #667eea 0%, #764ba2 100%);
      --card-shadow: 0 4px 16px rgba(100,100,100,0.15);
      --accent: #43cea2;
      --mini-active: #43cea2;
      --mini-inactive: #f8ffae;
      --mini-border: #b2b2b2;
      --mini-readonly: #e0e0e0;
      --button-bg: linear-gradient(90deg, #ffecd2 0%, #fcb69f 100%);
      --button-hover: linear-gradient(90deg, #fcb69f 0%, #ffecd2 100%);
      --button-shadow: 0 2px 8px rgba(255, 140, 100, 0.15);
    }
    html, body {
      height: 100%;
    }
    body {
      min-height: 100vh;
      background: var(--main-bg);
      font-family: 'Segoe UI', 'Apple SD Gothic Neo', Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    .tab-bar {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 2px 10px #43cea220;
      padding: 0.3rem 0;
      position: sticky;
      top: 0;
      z-index: 10;
      gap: 0.5rem;
    }
    .tab-btn {
      border: none;
      background: none;
      font-size: 1.1rem;
      font-weight: bold;
      color: #888;
      padding: 0.7rem 1.6rem;
      border-radius: 2rem 2rem 0 0;
      cursor: pointer;
      transition: color 0.2s, background 0.2s;
      outline: none;
      margin: 0 0.2rem;
    }
    .tab-btn.active {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 2px 10px #43cea220;
    }
    .screen {
      display: none;
      min-height: 80vh;
      width: 100vw;
      max-width: 600px;
      margin: 0 auto;
      padding: 2.5rem 1rem 2rem 1rem;
      box-sizing: border-box;
      animation: fadeIn 0.5s;
    }
    .screen.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(30px);}
      to { opacity: 1; transform: translateY(0);}
    }
    /* 규칙 화면 */
    .rules {
      background: rgba(255,255,255,0.6);
      border-radius: 18px;
      box-shadow: 0 4px 16px rgba(67,206,162,0.06);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 440px;
      margin: 0 auto;
      padding: 1.2rem 1rem 1.5rem 1rem;
    }
    .rules h2 {
      margin-bottom: 1.2rem;
      font-size: 1.55rem;
      color: #333;
      letter-spacing: 1px;
    }
    .rules-editor-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.2rem;
      width: 100%;
      justify-items: center;
    }
    .rule-label {
      margin: 0.5rem 0 0.2rem 0;
      font-weight: bold;
      color: #333;
      text-align: center;
      font-size: 1.08rem;
      letter-spacing: 0.5px;
    }
    .mini-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      margin-top: 0.1rem;
      background: #f8ffae;
      border-radius: 7px;
      box-shadow: 0 1px 4px #43cea230;
      padding: 2px;
    }
    .mini-cell {
      aspect-ratio: 1;
      background: var(--mini-inactive);
      border: 1.5px solid var(--mini-border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      cursor: pointer;
      border-radius: 5px;
      transition: background 0.2s, color 0.2s;
      color: #888;
      font-weight: 500;
      user-select: none;
    }
    .mini-cell.active {
      background: var(--mini-active);
      color: #fff;
      border-color: #43cea2;
      font-weight: bold;
      box-shadow: 0 0 6px #43cea270;
    }
    .mini-cell.read-only {
      background: var(--mini-readonly);
      color: #bbb;
      cursor: not-allowed;
      opacity: 0.7;
      border-style: dashed;
      box-shadow: none;
    }
    /* 게임 화면 */
    .game-container {
      background: rgba(255,255,255,0.55);
      border-radius: 18px;
      box-shadow: 0 4px 16px rgba(250, 168, 133, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 440px;
      margin: 0 auto;
      padding: 1.2rem 1rem 1.5rem 1rem;
    }
    h1 {
      font-size: 2.2rem;
      margin-bottom: 1.2rem;
      color: #333;
      letter-spacing: 1px;
      text-shadow: 0 2px 8px #fcb69f30;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.7rem;
      width: 100%;
      max-width: 400px;
      margin-top: 0.3rem;
    }
    .card {
      aspect-ratio: 1;
      font-size: 3.2rem !important;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      font-weight: bold;
      background: var(--card-front);
      box-shadow: var(--card-shadow);
      color: #fff;
      user-select: none;
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
    }
    .card.back {
      background: var(--card-back);
      color: #f8ffae;
      text-shadow: 0 2px 8px #764ba2af;
    }
    .card:active {
      box-shadow: 0 2px 8px #43cea270;
      filter: brightness(0.95);
    }
    button {
      margin-top: 1.5rem;
      padding: 1rem 2.2rem;
      font-size: 1.2rem;
      border-radius: 10px;
      border: none;
      background: var(--button-bg);
      color: #333;
      font-weight: bold;
      letter-spacing: 1px;
      box-shadow: var(--button-shadow);
      cursor: pointer;
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
    }
    button:hover, button:active {
      background: var(--button-hover);
      color: #222;
      box-shadow: 0 2px 12px #fcb69f60;
    }
    /* 승리 애니메이션 */
    .win-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 999;
      background: rgba(0,0,0,0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.5s;
    }
    .win-content {
      background: #fffbe6;
      border-radius: 30px;
      padding: 2.5rem 2rem 2rem 2rem;
      box-shadow: 0 8px 32px #43cea250;
      display: flex;
      flex-direction: column;
      align-items: center;
      animation: popIn 0.6s;
      position: relative;
    }
    @keyframes popIn {
      0% { transform: scale(0.7); opacity: 0;}
      70% { transform: scale(1.08);}
      100% { transform: scale(1); opacity: 1;}
    }
    .win-emoji {
      font-size: 3.5rem;
      animation: bounce 1.2s infinite;
      margin-bottom: 0.7rem;
    }
    @keyframes bounce {
      0%,100% { transform: translateY(0);}
      50% { transform: translateY(-18px);}
    }
    .win-title {
      font-size: 2rem;
      font-weight: bold;
      color: #43cea2;
      margin-bottom: 0.5rem;
      letter-spacing: 1px;
      text-align: center;
    }
    .win-msg {
      font-size: 1.15rem;
      color: #333;
      margin-bottom: 1.3rem;
      text-align: center;
    }
    .win-close {
      font-size: 1.1rem;
      border: none;
      border-radius: 8px;
      background: var(--button-bg);
      color: #222;
      font-weight: bold;
      padding: 0.6rem 1.5rem;
      cursor: pointer;
      box-shadow: 0 2px 8px #fcb69f40;
      transition: background 0.18s, color 0.18s;
    }
    .win-close:hover, .win-close:active {
      background: var(--button-hover);
      color: #111;
    }
    /* 반응형 */
    @media (max-width: 700px) {
      .screen { padding: 1.2rem 0.2rem 1.5rem 0.2rem; }
      .rules, .game-container { max-width: 100vw; padding: 1rem 0.3rem; }
      .grid { gap: 0.35rem; }
      .card { font-size: 2.2rem !important; }
      h1 { font-size: 1.4rem; }
    }
    @media (max-width: 420px) {
      .win-content { padding: 1.2rem 0.5rem 1.2rem 0.5rem;}
      .screen { padding: 0.4rem 0.1rem;}
    }
  </style>
</head>
<body>
  <div class="tab-bar">
    <button class="tab-btn active" id="tab-rule" onclick="showScreen('rule')">규칙 설정</button>
    <button class="tab-btn" id="tab-game" onclick="showScreen('game')">Merlin Game</button>
  </div>
  <div class="screen active" id="screen-rule">
    <div class="rules">
      <h2>규칙 설정</h2>
      <div id="customGrid" class="rules-editor-grid"></div>
    </div>
  </div>
  <div class="screen" id="screen-game">
    <div class="game-container">
      <h1>Merlin Game</h1>
      <div class="grid" id="grid"></div>
      <button onclick="resetGame()">🔄 새로 시작</button>
    </div>
  </div>
  <!-- 승리 모달 -->
  <div id="winModal" class="win-modal" style="display:none;">
    <div class="win-content">
      <div class="win-emoji">✨🧙‍♂️✨</div>
      <div class="win-title">마법 성공!</div>
      <div class="win-msg">
        모든 카드를 앞면으로 뒤집었습니다!<br>
        <span style="font-size:1.2em;">🎩 "Merlin"도 감탄하는 실력!</span><br>
        <span style="color:#fda085;">다시 도전해볼까요?</span>
      </div>
      <button class="win-close" onclick="closeWinModal()">닫기</button>
    </div>
  </div>
  <script>
    // 3x3 격자 좌표 변환 (1~9 <-> [row, col])
    function idxToRC(idx) { return [Math.floor((idx-1)/3), (idx-1)%3]; }
    function rcToIdx(r, c) { return r*3 + c + 1; }

    // 90도 회전
    function rotate90(idx) {
      const [r, c] = idxToRC(idx);
      return rcToIdx(c, 2 - r);
    }
    // 180도 회전
    function rotate180(idx) { return rotate90(rotate90(idx)); }
    // 270도 회전
    function rotate270(idx) { return rotate90(rotate180(idx)); }

    // 규칙 에디터에서 사용할 대표 규칙(B1, B2, B5)
    let baseRules = {
      1: [1], // B1 (좌상단, 모서리 그룹)
      2: [2], // B2 (상중앙, 변중앙 그룹)
      5: [5], // B5 (중앙)
    };

    // 실제 게임에서 사용할 9개 버튼의 규칙
    let flipMap = {};

    // baseRules를 바탕으로 flipMap 전체 생성
    function updateFlipMap() {
      // B1, B3, B7, B9 (모서리)
      flipMap[1] = baseRules[1].slice();
      flipMap[3] = baseRules[1].map(rotate90);
      flipMap[9] = baseRules[1].map(rotate180);
      flipMap[7] = baseRules[1].map(rotate270);
      // B2, B4, B6, B8 (변 중앙)
      flipMap[2] = baseRules[2].slice();
      flipMap[6] = baseRules[2].map(rotate90);
      flipMap[8] = baseRules[2].map(rotate180);
      flipMap[4] = baseRules[2].map(rotate270);
      // B5 (중앙)
      flipMap[5] = baseRules[5].slice();
    }

    // 카드 상태
    let cardStates = Array(9).fill().map(() => Math.random() < 0.5);

    function renderGrid() {
      const grid = document.getElementById("grid");
      grid.innerHTML = '';
      cardStates.forEach((state, i) => {
        const card = document.createElement('div');
        card.className = `card ${state ? '' : 'back'}`;
        card.textContent = state ? i + 1 : 'X';
        card.onclick = () => handleClick(i + 1);
        grid.appendChild(card);
      });
    }

    function handleClick(num) {
      flipMap[num].forEach(n => cardStates[n - 1] = !cardStates[n - 1]);
      renderGrid();
      if (cardStates.every(s => s)) setTimeout(showWinModal, 100);
    }

    function resetGame() {
      cardStates = Array(9).fill().map(() => Math.random() < 0.5);
      renderGrid();
    }

    function renderRuleEditor() {
      const container = document.getElementById("customGrid");
      // 각 버튼에 대한 레이블
      const ruleNames = {
        1: "B1<br><small>(편집 가능)</small>",
        2: "B2<br><small>(편집 가능)</small>",
        5: "B5<br><small>(편집 가능)</small>",
        3: "B3<br><small>(자동)</small>",
        4: "B4<br><small>(자동)</small>",
        6: "B6<br><small>(자동)</small>",
        7: "B7<br><small>(자동)</small>",
        8: "B8<br><small>(자동)</small>",
        9: "B9<br><small>(자동)</small>"
      };
      // 1~9 버튼 모두 표시
      container.innerHTML = Array.from({length: 9}, (_, i) => i + 1).map(btn => `
        <div>
          <div class="rule-label">${ruleNames[btn]}</div>
          <div class="mini-grid">
            ${Array.from({length: 9}, (_, j) => {
              const cellNum = j + 1;
              const isEditable = [1, 2, 5].includes(btn);
              const isActive = isEditable 
                ? baseRules[btn].includes(cellNum) 
                : flipMap[btn].includes(cellNum);
              const cellClass = [
                "mini-cell",
                isActive ? "active" : "",
                isEditable ? "" : "read-only"
              ].join(" ");
              // 클릭 이벤트는 편집 가능 버튼만
              return `
                <div class="${cellClass}" 
                  ${isEditable ? `onclick="toggleRule(${btn}, ${cellNum})"` : ""}
                >
                  ${isActive ? '●' : '○'}
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `).join('');
    }

    // 대표 규칙 토글
    window.toggleRule = function(ruleNum, targetNum) {
      const arr = baseRules[ruleNum];
      const idx = arr.indexOf(targetNum);
      if (idx > -1) arr.splice(idx, 1);
      else arr.push(targetNum);
      updateFlipMap();
      renderRuleEditor();
    };

    // 화면 전환
    function showScreen(which) {
      document.getElementById('screen-rule').classList.toggle('active', which === 'rule');
      document.getElementById('screen-game').classList.toggle('active', which === 'game');
      document.getElementById('tab-rule').classList.toggle('active', which === 'rule');
      document.getElementById('tab-game').classList.toggle('active', which === 'game');
      // 게임 화면 진입시 항상 그리드 새로고침
      if (which === 'game') {
        updateFlipMap();
        renderGrid();
      }
      if (which === 'rule') {
        renderRuleEditor();
      }
    }

    // 승리 모달
    function showWinModal() {
      document.getElementById('winModal').style.display = 'flex';
    }
    function closeWinModal() {
      document.getElementById('winModal').style.display = 'none';
      resetGame();
    }

    // 초기화
    document.addEventListener('DOMContentLoaded', () => {
      updateFlipMap();
      renderRuleEditor();
      renderGrid();
    });
  </script>
</body>
</html>
