<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Merlin Game</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 1rem;
      min-height: 100vh;
    }
    .rules { flex: 1; min-width: 300px; max-width: 400px; }
    .rules h2 { margin-bottom: 1rem; font-size: 1.5rem; }
    .rules-editor-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
    }
    .game-container {
      flex: 1;
      min-width: 300px;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { font-size: 2rem; margin-bottom: 1rem; }
    .grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
      width: 100%;
      max-width: 400px;
    }
    .card {
      aspect-ratio: 1;
      font-size: 3rem !important;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid #444;
      border-radius: 10px;
      cursor: pointer;
      background: #ddd;
      font-weight: bold;
    }
    .card.back { background: #666; color: white; }
    button {
      margin-top: 1.5rem;
      padding: 1rem 2rem;
      font-size: 1.2rem;
      border-radius: 8px;
    }
    .mini-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      margin-top: 0.5rem;
    }
    .mini-cell {
      aspect-ratio: 1;
      background: #eee;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .mini-cell.active { background: #222; color: white; }
    @media (max-width: 768px) {
      body { flex-direction: column; padding: 0.5rem; gap: 0.5rem; }
      .rules, .game-container { width: 100%; max-width: 100%; }
      .grid { max-width: 100%; gap: 0.3rem; }
      .card { font-size: 2.5rem !important; }
      button { padding: 0.8rem 1.5rem; font-size: 1rem; }
      .mini-cell { font-size: 0.7rem; }
    }
    @media (max-width: 480px) and (orientation: portrait) {
      .card { font-size: 2rem !important; }
      h1 { font-size: 1.5rem; }
    }
  </style>
</head>
<body>
  <div class="rules">
    <h2>ğŸ“œ ê·œì¹™ ì„¤ì •</h2>
    <div id="customGrid" class="rules-editor-grid"></div>
  </div>
  <div class="game-container">
    <h1>ğŸ§™ ë§¤ì§ ì¹´ë“œ ê²Œì„</h1>
    <div class="grid" id="grid"></div>
    <button onclick="resetGame()">ğŸ”„ ìƒˆë¡œ ì‹œì‘</button>
  </div>
  <script>
    // ëŒ€ì¹­ ì¸ë±ìŠ¤ ë§¤í•‘ (1-based)
    // 1 2 3
    // 4 5 6
    // 7 8 9
    // B1 <-> B3 <-> B7 <-> B9 (ëŒ€ê° ëŒ€ì¹­)
    // B2 <-> B4 <-> B6 <-> B8 (ë³€ ì¤‘ì•™ ëŒ€ì¹­)
    // B5 (ì¤‘ì•™)
    const symmetryMap = {
      1: 1, 2: 2, 3: 3,
      4: 4, 5: 5, 6: 6,
      7: 7, 8: 8, 9: 9
    };
    // ê° ë²„íŠ¼ì˜ ëŒ€ì¹­ ê·¸ë£¹
    const cornerGroup = [1, 3, 7, 9];
    const edgeGroup = [2, 4, 6, 8];
    const centerGroup = [5];

    // ê·œì¹™ ì—ë””í„°ì—ì„œ ì‚¬ìš©í•  ëŒ€í‘œ ê·œì¹™(B1, B2, B5)
    let baseRules = {
      1: [1], // B1 (ì¢Œìƒë‹¨)
      2: [2], // B2 (ìƒì¤‘ì•™)
      5: [5], // B5 (ì¤‘ì•™)
    };

    // ì‹¤ì œ ê²Œì„ì—ì„œ ì‚¬ìš©í•  9ê°œ ë²„íŠ¼ì˜ ê·œì¹™
    let flipMap = {};

    // baseRulesë¥¼ ë°”íƒ•ìœ¼ë¡œ flipMap ì „ì²´ ìƒì„±
    function updateFlipMap() {
      // corners
      cornerGroup.forEach((btn, idx) => {
        // ëŒ€ì¹­ ìˆœì„œ: 1-3-9-7 (ì‹œê³„ë°©í–¥)
        // baseRules[1]ì˜ ê° ì…€ë„ ì‹œê³„ë°©í–¥ìœ¼ë¡œ ëŒ€ì¹­
        flipMap[btn] = baseRules[1].map(cell => {
          // cellì˜ ëŒ€ì¹­ ìœ„ì¹˜ ì°¾ê¸°
          const cornerCells = [1, 3, 9, 7];
          const i = cornerCells.indexOf(cell);
          if (i !== -1) return cornerCells[(i + idx) % 4];
          // edgeCells ëŒ€ì¹­
          const edgeCells = [2, 6, 8, 4];
          const j = edgeCells.indexOf(cell);
          if (j !== -1) return edgeCells[(j + idx) % 4];
          // center
          if (cell === 5) return 5;
          return cell;
        });
      });
      // edges
      edgeGroup.forEach((btn, idx) => {
        // ëŒ€ì¹­ ìˆœì„œ: 2-6-8-4 (ì‹œê³„ë°©í–¥)
        flipMap[btn] = baseRules[2].map(cell => {
          const edgeCells = [2, 6, 8, 4];
          const i = edgeCells.indexOf(cell);
          if (i !== -1) return edgeCells[(i + idx) % 4];
          const cornerCells = [1, 3, 9, 7];
          const j = cornerCells.indexOf(cell);
          if (j !== -1) return cornerCells[(j + idx) % 4];
          if (cell === 5) return 5;
          return cell;
        });
      });
      // center
      flipMap[5] = baseRules[5].slice();
    }

    // ì¹´ë“œ ìƒíƒœ
    let cardStates = Array(9).fill().map(() => Math.random() < 0.5);

    function renderGrid() {
      const grid = document.getElementById("grid");
      grid.innerHTML = '';
      cardStates.forEach((state, i) => {
        const card = document.createElement('div');
        card.className = `card ${state ? '' : 'back'}`;
        card.textContent = state ? i + 1 : 'X';
        card.onclick = () => handleClick(i + 1);
        grid.appendChild(card);
      });
    }

    function handleClick(num) {
      flipMap[num].forEach(n => cardStates[n - 1] = !cardStates[n - 1]);
      renderGrid();
      if (cardStates.every(s => s)) setTimeout(() => alert('ğŸ‰ ì„±ê³µ! ëª¨ë“  ì¹´ë“œë¥¼ ë’¤ì§‘ì—ˆìŠµë‹ˆë‹¤!'), 50);
    }

    function resetGame() {
      cardStates = Array(9).fill().map(() => Math.random() < 0.5);
      renderGrid();
    }

    function renderRuleEditor() {
      const container = document.getElementById("customGrid");
      // B1, B2, B5ë§Œ í‘œì‹œ
      const ruleNames = {1: "B1 (ë„¤ ëª¨ì„œë¦¬)", 2: "B2 (ë„¤ ë³€ ì¤‘ì•™)", 5: "B5 (ì¤‘ì•™)"};
      container.innerHTML = [1, 2, 5].map((btn) => `
        <div>
          <div style="margin: 0.5rem 0; font-weight: bold">${ruleNames[btn]}</div>
          <div class="mini-grid">
            ${Array(9).fill().map((_, j) => `
              <div class="mini-cell ${baseRules[btn].includes(j+1) ? 'active' : ''}"
                   onclick="toggleRule(${btn}, ${j+1})">
                ${baseRules[btn].includes(j+1) ? 'â—' : 'â—‹'}
              </div>
            `).join('')}
          </div>
        </div>
      `).join('');
    }

    // ëŒ€í‘œ ê·œì¹™ í† ê¸€
    window.toggleRule = function(ruleNum, targetNum) {
      const arr = baseRules[ruleNum];
      const idx = arr.indexOf(targetNum);
      if (idx > -1) arr.splice(idx, 1);
      else arr.push(targetNum);
      updateFlipMap();
      renderRuleEditor();
    };

    // ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', () => {
      updateFlipMap();
      renderGrid();
      renderRuleEditor();
    });
  </script>
</body>
</html>
